# TensorScan FFI bridge (CBQN).
# ts_snapshot signature:
#   size_t ts_snapshot(double* out, size_t max_rows, size_t max_cols,
#                      double* pid_out)
# ts_core_count signature:
#   size_t ts_core_count(size_t ignored)
# Adjust the signature string if your CBQN build uses different type codes.

lib â† â€¢FFI (â€¢path) âˆ¾ "/libtensorscan.so"

# "p" = pointer, "n" = size_t (native word). Return is size_t.
tsSnapshot â† Lib âŸ¨"ts_snapshot", "pnnp>n"âŸ©
tsSnapshotFiltered â† Lib âŸ¨"ts_snapshot_filtered", "pnnpffpnf>n"âŸ©
tsSnapshotDelta â† Lib âŸ¨"ts_snapshot_delta", "pnnp>n"âŸ©
tsCoreCount â† Lib âŸ¨"ts_core_count", "n>n"âŸ©
tsUsleep â† Lib âŸ¨"ts_usleep", "n>"âŸ©
tsGetMonotonicTime â† Lib âŸ¨"ts_get_monotonic_time", "n>f"âŸ©
tsGetMetricCount â† Lib âŸ¨"ts_get_metric_count", "n>n"âŸ©
tsGetTotalCpuTicks â† Lib âŸ¨"ts_get_total_cpu_ticks", "n>n"âŸ©
tsGetMemTotalBytes â† Lib âŸ¨"ts_get_mem_total_bytes", "n>n"âŸ©
tsReadComm â† Lib âŸ¨"ts_read_comm", "npn>n"âŸ©
tsReadCmdline â† Lib âŸ¨"ts_read_cmdline", "npn>n"âŸ©
tsReadCgroup â† Lib âŸ¨"ts_read_cgroup", "npn>n"âŸ©
tsGetMetricIndex â† Lib âŸ¨"ts_get_metric_index", "p>i"âŸ©
tsFreeThreadResources â† Lib âŸ¨"ts_free_thread_resources", "n>"âŸ©

GetMetricIndex â† { TsGetMetricIndex ğ•© }

utime â† GetMetricIndex "utime"
stime â† GetMetricIndex "stime"
rss â† GetMetricIndex "rss"
vsize â† GetMetricIndex "vsize"
num_threads â† GetMetricIndex "num_threads"
vol_ctx â† GetMetricIndex "vol_ctx"
nonvol_ctx â† GetMetricIndex "nonvol_ctx"
processor â† GetMetricIndex "processor"
io_read â† GetMetricIndex "io_read"
io_write â† GetMetricIndex "io_write"
starttime â† GetMetricIndex "starttime"
uid â† GetMetricIndex "uid"
ppid â† GetMetricIndex "ppid"
priority â† GetMetricIndex "priority"
nice â† GetMetricIndex "nice"
minflt â† GetMetricIndex "minflt"
majflt â† GetMetricIndex "majflt"

counterMetrics â† âŸ¨utime, stime, vol_ctx, nonvol_ctx,
  io_read, io_write, minflt, majfltâŸ©

ReadComm â† {
  pid â† ğ•©
  buf â† 256 â¥Š 0
  n â† TsReadComm pidâ€¿bufâ€¿256
  @+ n â†‘ buf
}

ReadCmdline â† {
  pid â† ğ•©
  buf â† 4096 â¥Š 0
  n â† TsReadCmdline pidâ€¿bufâ€¿4096
  @+ n â†‘ buf
}

ReadCgroup â† {
  pid â† ğ•©
  buf â† 1024 â¥Š 0
  n â† TsReadCgroup pidâ€¿bufâ€¿1024
  @+ n â†‘ buf
}

MetricCount â† {ğ•Š: TsGetMetricCount 0 }
CoreCount â† {ğ•Š: TsCoreCount 0 }
TotalCpuTicks â† {ğ•Š: TsGetTotalCpuTicks 0 }
MemTotalBytes â† {ğ•Š: TsGetMemTotalBytes 0 }

# Take one snapshot into a fresh buffer and return âŸ¨timestamp, count, pids, matrixâŸ©.
Snapshot â† {
  rowsâ€¿cols â† ğ•©
  buf â† (rowsâ€¿cols) â¥Š 0
  pids â† rows â¥Š 0
  t â† TsGetMonotonicTime 0
  count â† TsSnapshot bufâ€¿rowsâ€¿colsâ€¿pids
  pids_s â† (rowsâŒŠcount) â†‘ pids
  buf_s â† (rowsâŒŠcount) â†‘ buf
  # Safety: filter out any rows with pid=0 or starttime=0 to prevent alignment pollution.
  keep â† (pids_s â‰  0) âˆ§ (starttime âŠ â‰ buf_s) â‰  0
  âŸ¨t, +Â´ keep, keep / pids_s, keep / buf_sâŸ©
}

# Filtered snapshot. Use Â¯1 for pid_min/pid_max/only_uid to disable.
SnapshotFiltered â† {
  rowsâ€¿colsâ€¿pid_minâ€¿pid_maxâ€¿pid_whitelistâ€¿only_uid â† ğ•©
  buf â† (rowsâ€¿cols) â¥Š 0
  pids â† rows â¥Š 0
  t â† TsGetMonotonicTime 0
  count â† TsSnapshotFiltered bufâ€¿rowsâ€¿colsâ€¿pidsâ€¿pid_minâ€¿pid_maxâ€¿pid_whitelistâ€¿(â‰ pid_whitelist)â€¿only_uid
  pids_s â† (rowsâŒŠcount) â†‘ pids
  buf_s â† (rowsâŒŠcount) â†‘ buf
  keep â† (pids_s â‰  0) âˆ§ (starttime âŠ â‰ buf_s) â‰  0
  âŸ¨t, +Â´ keep, keep / pids_s, keep / buf_sâŸ©
}

# Delta-ready snapshot (counter metrics are deltas).
SnapshotDelta â† {
  rowsâ€¿cols â† ğ•©
  buf â† (rowsâ€¿cols) â¥Š 0
  pids â† rows â¥Š 0
  t â† TsGetMonotonicTime 0
  count â† TsSnapshotDelta bufâ€¿rowsâ€¿colsâ€¿pids
  pids_s â† (rowsâŒŠcount) â†‘ pids
  buf_s â† (rowsâŒŠcount) â†‘ buf
  keep â† (pids_s â‰  0) âˆ§ (starttime âŠ â‰ buf_s) â‰  0
  âŸ¨t, +Â´ keep, keep / pids_s, keep / buf_sâŸ©
}

# Capture t snapshots using fold. Returns a list of âŸ¨count, pids, matrixâŸ©.
# Uses a monotonic clock to avoid timing drift.
# Now accepts 'interval' (in seconds) as an argument.
Capture â† {
  tâ€¿rowsâ€¿colsâ€¿interval â† ğ•©
  start â† TsGetMonotonicTime 0
  Step â† {
    accâ€¿next â† ğ•¨
    wait â† 0 âŒˆ next - TsGetMonotonicTime 0
    TsUsleep âŒŠ 1e6 Ã— wait
    âŸ¨acc âˆ¾ âŸ¨Snapshot rowsâ€¿colsâŸ©, next + intervalâŸ©
  }
  0 âŠ‘ âŸ¨âŸ¨âŸ©, start + intervalâŸ© StepÂ´ â†•t
}

# Extract the processor/core-id column from a snapshot matrix.
CoreIds â† {
  matâ€¿proc_idx â† ğ•©
  proc_idx âŠ â‰ mat
}

# One-hot encode core ids for a snapshot.
# Output shape: pÃ—c (p processes, c cores).
CoreOneHot â† {
  matâ€¿proc_idxâ€¿cores â† ğ•©
  ids â† CoreIds matâ€¿proc_idx
  valid â† (0 â‰¤ ids) âˆ§ (ids < cores)
  safe_ids â† (cores - 1) âŒŠ 0 âŒˆ ids
  (safe_ids =âŒœ â†•cores) Ã— (valid âŒœâŠ£ â†•cores)
}

# Build PID keys using âŸ¨pid, starttimeâŸ© pairs.
PidKeys â† {
  snap â† ğ•©
  pids â† 2 âŠ‘ snap
  mat â† 3 âŠ‘ snap
  start â† starttime âŠ â‰ mat
  â‰ (pidsâ€¿start)
}

PidList â† { keys â† ğ•© â‹„ 0 âŠ â‰ keys }
StartList â† { keys â† ğ•© â‹„ 1 âŠ â‰ keys }

# Build a stable PID key axis from a list of snapshots.
AllKeys â† {
  snaps â† ğ•©
  keys â† âˆ¾ (PidKeysÂ¨ snaps)
  ((keys âŠ keys) = (â†•â‰ keys)) / keys
}

AllPids â† {
  snaps â† ğ•©
  PidList (AllKeys snaps)
}

# Align a single snapshot's matrix to the stable PID axis.
AlignSnapshot â† {
  snapâ€¿all_keys â† ğ•©
  keys â† PidKeys snap
  mat â† 3 âŠ‘ snap
  (pâ€¿m) â† â‰¢ mat
  idx â† keys âŠ all_keys
  mat0 â† mat âˆ¾ (1â€¿m) â¥Š 0
  miss â† (idx < 0) âˆ¨ (idx â‰¥ p)
  safe_idx â† (idx Ã— (1 - miss)) + (miss Ã— p)
  rows â† safe_idx âŠ mat0
  rows
}

# Align a list of snapshots to a stable PID axis.
AlignSeries â† {
  snaps â† ğ•©
  all_keys â† AllKeys snaps
  times â† {0 âŠ ğ•©}Â¨ snaps
  mats â† {snap â† ğ•© â‹„ AlignSnapshot snapâ€¿all_keys}Â¨ snaps
  âŸ¨all_keys, times, matsâŸ©
}

# Build a tÃ—pÃ—m tensor from aligned matrices.
Tensor3D â† {
  snaps â† ğ•©
  all_keysâ€¿timesâ€¿mats â† AlignSeries snaps
  t â† â‰ mats
  (pâ€¿m) â† â‰¢ (0 âŠ‘ mats)
  flat â† âˆ¾ mats
  âŸ¨all_keys, times, (tâ€¿pâ€¿m) â¥Š flatâŸ©
}

# Expand one snapshot matrix to include a core axis.
# Output shape: pÃ—mÃ—c with processor metric replaced by one-hot.
ExpandCore â† {
  matâ€¿cores â† ğ•©
  (pâ€¿m) â† â‰¢ mat
  core_hot â† CoreOneHot matâ€¿processorâ€¿cores
  broad â† mat âŒœâŠ£ â†•cores
  broad_m â† broad â‰ âŸ¨1,0,2âŸ©
  core_hot2 â† (1â€¿pâ€¿cores) â¥Š core_hot
  before â† processor â†‘ broad_m
  after â† (processor + 1) â†“ broad_m
  merged â† before âˆ¾ core_hot2 âˆ¾ after
  merged â‰ âŸ¨1,0,2âŸ©
}

# Expand to full 4D tensor with core axis.
# Returns âŸ¨all_keys, times, tensorâŸ© where tensor is tÃ—pÃ—mÃ—c.
Tensor4D â† {
  snapsâ€¿cores â† ğ•©
  all_keysâ€¿timesâ€¿mats â† AlignSeries snaps
  t â† â‰ mats
  (pâ€¿m) â† â‰¢ (0 âŠ‘ mats)
  expanded â† {mat â† ğ•© â‹„ ExpandCore matâ€¿cores}Â¨ mats
  flat â† âˆ¾ expanded
  âŸ¨all_keys, times, (tâ€¿pâ€¿mâ€¿cores) â¥Š flatâŸ©
}

# Extract one metric slice. Output: tÃ—pÃ—c.
MetricSlice â† {
  tensorâ€¿metric_idx â† ğ•©
  metric_idx âŠ (tensor â‰ âŸ¨2,0,1,3âŸ©)
}

# Convert cumulative counters to per-interval deltas and normalize by time.
# Output shape is (t-1)Ã—pÃ—mÃ—c.
ToDeltas â† {
  timesâ€¿tensor â† ğ•©
  (tâ€¿pâ€¿mâ€¿c) â† â‰¢ tensor
  t1 â† 0 âŒˆ (t - 1)
  dt â† (1 â†“ times) - (Â¯1 â†“ times)
  # Add small epsilon to dt to avoid div-by-zero, though unlikely with monotonic clock.
  dt â†© dt + dt = 0
  d â† (1â†“tensor) - (Â¯1â†“tensor)
  g â† 1â†“tensor
  presentC â† 0 < MetricSlice tensorâ€¿starttime
  pairC â† (1â†“presentC) âˆ§ (Â¯1â†“presentC)
  per_metric â† {
    i â† ğ•©
    sel â† 0 < +Â´ (i = counterMetrics)
    di â† MetricSlice dâ€¿i
    gi â† MetricSlice gâ€¿i
    # Valid if neither previous nor current sample is -1 (IO sentinel)
    validC â† (Â¯1â†“MetricSlice tensorâ€¿i) â‰  Â¯1
    pairC2 â† pairC âˆ§ validC âˆ§ (gi â‰  Â¯1)
    raw_delta â† 0 âŒˆ (di Ã— pairC2)
    # Normalize by time elapsed (dt). Reshape dt for broadcasting: (t-1)Ã—1Ã—1.
    norm_delta â† raw_delta Ã· dt âŒœâŠ£ (â†•p) âŒœâŠ£ (â†•c)
    sel Ã— norm_delta + (1 - sel) Ã— gi
  }Â¨ â†•m
  tmp â† (mâ€¿t1â€¿pâ€¿c) â¥Š âˆ¾ per_metric
  tmp â‰ âŸ¨1,2,0,3âŸ©
}

# Move time axis to the last position.
TimeLast â† {
  tensor â† ğ•©
  tensor â‰ âŸ¨1,2,3,0âŸ©
}

# Mean over time axis. Input: tÃ—pÃ—mÃ—c. Output: pÃ—mÃ—c.
MeanT â† {
  tensor â† ğ•©
  tlast â† TimeLast tensor
  n â† Â¯1 âŠ‘ â‰¢ tlast
  (+Â´ tlast) Ã· n
}

# Variance over time axis. Input: tÃ—pÃ—mÃ—c. Output: pÃ—mÃ—c.
VarT â† {
  tensor â† ğ•©
  tlast â† TimeLast tensor
  n â† Â¯1 âŠ‘ â‰¢ tlast
  mean â† (+Â´ tlast) Ã· n
  mean_full â† (â‰¢ tlast) â¥Š mean
  d â† tlast - mean_full
  (+Â´ (d Ã— d)) Ã· n
}

StdT â† { âˆš VarT ğ•© }

# Micro-stutter mask: spikes high but low mean over time.
# Returns pÃ—c boolean mask.
MicroStutterMask â† {
  timesâ€¿tensorâ€¿metric_idxâ€¿spike_threshâ€¿mean_thresh â† ğ•©
  metric â† MetricSlice (ToDeltas timesâ€¿tensor)â€¿metric_idx
  tlast â† metric â‰ âŸ¨1,2,0âŸ©
  n â† Â¯1 âŠ‘ â‰¢ tlast
  mean â† (+Â´ tlast) Ã· n
  mx â† âŒˆÂ´ tlast
  (mx > spike_thresh) âˆ§ (mean < mean_thresh)
}

# Stealth detection: z-score of per-(p,m,c) stddev vs global stddev.
StealthZ â† {
  timesâ€¿tensor â† ğ•©
  s â† StdT (ToDeltas timesâ€¿tensor)
  r â† âˆ¾ s
  mu â† (+Â´ r) Ã· â‰  r
  sigma â† âˆš ((+Â´ ((r - mu) Ã— (r - mu))) Ã· â‰  r)
  (s - mu) Ã· sigma
}

# IO burst but low CPU usage.
IOBurstLowCPU â† {
  timesâ€¿tensorâ€¿io_threshâ€¿cpu_thresh â† ğ•©
  d â† ToDeltas timesâ€¿tensor
  io â† (MetricSlice dâ€¿io_read) + (MetricSlice dâ€¿io_write)
  cpu â† (MetricSlice dâ€¿utime) + (MetricSlice dâ€¿stime)
  io_tlast â† io â‰ âŸ¨1,2,0âŸ©
  cpu_tlast â† cpu â‰ âŸ¨1,2,0âŸ©
  n â† Â¯1 âŠ‘ â‰¢ io_tlast
  io_peak â† âŒˆÂ´ io_tlast
  cpu_mean â† (+Â´ cpu_tlast) Ã· n
  (io_peak > io_thresh) âˆ§ (cpu_mean < cpu_thresh)
}

# CPU burst concentrated on a single core.
CpuSingleCoreBurst â† {
  timesâ€¿tensorâ€¿spike_threshâ€¿other_thresh â† ğ•©
  d â† ToDeltas timesâ€¿tensor
  cpu â† (MetricSlice dâ€¿utime) + (MetricSlice dâ€¿stime)
  cpu_tlast â† cpu â‰ âŸ¨1,2,0âŸ©
  peak â† âŒˆÂ´ cpu_tlast
  maxc â† âŒˆÂ´ peak
  other â† (+Â´ peak) - maxc
  valid â† (maxc > spike_thresh) âˆ§ (other < other_thresh)
  c â† 1 âŠ‘ â‰¢ peak
  core_mask â† peak =âŒœ maxc
  validC â† valid âŒœâŠ£ â†•c
  core_mask âˆ§ validC
}

# Thread explosion: sudden large increases in thread count.
ThreadExplosion â† {
  tensorâ€¿delta_thresh â† ğ•©
  threads â† MetricSlice tensorâ€¿num_threads
  d â† (1â†“threads) - (Â¯1â†“threads)
  tlast â† d â‰ âŸ¨1,2,0âŸ©
  peak â† âŒˆÂ´ tlast
  peak > delta_thresh
}

# Density rendering helpers.
gradient â† " .:-=+*#%@"

Normalize â† {
  vals â† ğ•©
  r â† âˆ¾ vals
  r2 â† r âˆ¾ (0 = â‰ r) â¥Š 0
  mn â† âŒŠÂ´ r2
  mx â† âŒˆÂ´ r2
  den â† (mx - mn) + (mx = mn)
  (vals - mn) Ã· den
}

MapDensity â† {
  vals â† ğ•©
  g â† gradient
  n â† â‰  g
  idx â† âŒŠ (Normalize vals) Ã— (n - 1)
  g âŠ idx
}

# Render a timeÃ—pid heatmap for a chosen metric.
DensityMatrix â† {
  timesâ€¿tensorâ€¿metric_idx â† ğ•©
  metric â† MetricSlice (ToDeltas timesâ€¿tensor)â€¿metric_idx
  # Metric has shape tÃ—pÃ—c. Collapse c (take max) to get tÃ—p.
  âŒˆÂ´ (metric â‰ âŸ¨2,0,1âŸ©)
}

DensityView â† {
  timesâ€¿tensorâ€¿metric_idx â† ğ•©
  â€¢Show MapDensity DensityMatrix timesâ€¿tensorâ€¿metric_idx
}

# Example usage:
# rows â† 4096
# cols â† MetricCount 0
# buf â† (rowsâ€¿cols) â¥Š 0
# pids â† rows â¥Š 0
# count â† TsSnapshot bufâ€¿rowsâ€¿colsâ€¿pids
