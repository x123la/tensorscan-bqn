#!/usr/bin/env bqn

# Opinionated TUI: Live "Top" view using ANSI escapes.
# Usage: bqn lib/top.bqn --rows 1024 --history 50 --interval 0.1

ts â† â€¢Import (â€¢path) âˆ¾ "/tensor.bqn"
args â† â€¢Args

# --- Configuration ---
ParseArg â† {
  keyâ€¿default â† ğ•©
  idx â† args âŠ âŸ¨keyâŸ©
  idx < â‰ args ? â€¢ParseFloat (idx+1) âŠ‘ args ; default
}

rows     â† ParseArg "--rows"â€¿1024
history  â† ParseArg "--history"â€¿40    # Number of columns in the heatmap
interval â† ParseArg "--interval"â€¿0.2  # Refresh rate

cols  â† ts.MetricCount 0
cores â† ts.CoreCount 0

# --- ANSI Helpers ---
ClearScreen â† {ğ•Š: â€¢Out "\033[2J" }
CursorHome  â† {ğ•Š: â€¢Out "\033[H" }
HideCursor  â† {ğ•Š: â€¢Out "\033[?25l" }
ShowCursor  â† {ğ•Š: â€¢Out "\033[?25h" }
resetColor  â† "\033[0m"

# --- State Initialization ---
# We pre-allocate a list of "history" empty snapshots
# A snapshot is âŸ¨time, count, pids, matrixâŸ©
emptySnap â† âŸ¨0, 0, âŸ¨âŸ©, (0â€¿cols)â¥Š0âŸ©
buffer â† history â¥Š âŸ¨emptySnapâŸ©

# --- The Render Loop ---
Render â† {ğ•Š:
  CursorHome 0
  
  # 1. Convert Buffer to Tensor
  # Note: This is computationally heavy. In a C++ app we'd optimize.
  # In BQN, we rely on the interpreter's array speed.
  _â€¿timesâ€¿tensor â† ts.Tensor4D bufferâ€¿cores
  
  # 2. Header
  cpu_ticks â† ts.TotalCpuTicks 0
  mem_bytes â† ts.MemTotalBytes 0
  header â† "TensorScan Live | Interval: "âˆ¾(â€¢Fmt interval)âˆ¾"s | History: "âˆ¾(â€¢Fmt history)
  â€¢Out header âˆ¾ " | Memory: " âˆ¾ (â€¢Fmt âŒŠmem_bytesÃ·1024Ã·1024) âˆ¾ " MB"
  â€¢Out (80â¥Š"-")

  # 3. Visualization: utime Heatmap
  # We select utime (0). You could toggle this with input later.
  â€¢Out "Metric: utime (CPU Usage Density)"
  ts.DensityView timesâ€¿tensorâ€¿ts.utime
  
  # 4. Visualization: io_read Heatmap
  â€¢Out ""
  â€¢Out "Metric: io_read (Disk Activity)"
  ts.DensityView timesâ€¿tensorâ€¿ts.io_read
  
  â€¢Out resetColor âˆ¾ "\033[J" # Clear rest of screen
}

# --- Main Loop ---
Run â† {ğ•Š:
  ClearScreen 0
  HideCursor 0
  
  # Clean up cursor on exit
  { ShowCursor 0 } â€¢OnExit 0

  â€¢Out "Initializing buffer..."
  
  Loop â† {
    buf â† ğ•©
    # 1. Capture one frame
    new_snap â† ts.Snapshot rowsâ€¿cols
    
    # 2. Rotate buffer (Drop first, append new)
    next_buf â† (1 â†“ buf) âˆ¾ âŸ¨new_snapâŸ©
    
    # 3. Update global buffer for the renderer
    buffer â†© next_buf
    
    # 4. Render
    Render 0
    
    # 5. Wait
    ts.TsUsleep âŒŠ interval Ã— 1e6
    Loop next_buf
  }
  Loop buffer
}

Run 0
